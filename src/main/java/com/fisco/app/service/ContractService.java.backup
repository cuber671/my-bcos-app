package com.fisco.app.service;

import com.fisco.app.contract.Bill;
import com.fisco.app.contract.EnterpriseRegistry;
import com.fisco.app.contract.Receivable;
import com.fisco.app.contract.WarehouseReceipt;
import com.fisco.app.entity.Enterprise;
import com.fisco.app.exception.BlockchainIntegrationException;
import com.fisco.app.util.DataHashUtil;
import io.swagger.annotations.Api;
import lombok.extern.slf4j.Slf4j;
import org.fisco.bcos.sdk.v3.client.Client;
import org.fisco.bcos.sdk.v3.crypto.keypair.CryptoKeyPair;
import org.fisco.bcos.sdk.v3.model.TransactionReceipt;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.LocalDateTime;
import java.time.ZoneId;

/**
 * 智能合约服务
 * 负责加载智能合约实例并提供统一的合约调用接口
 */
@Slf4j
@Service
@ConditionalOnProperty(name = "fisco.enabled", havingValue = "true", matchIfMissing = true)
@Api(tags = "智能合约服务")
public class ContractService {

    private final Client client;
    private final CryptoKeyPair cryptoKeyPair;
    private final DataHashUtil dataHashUtil;

    @Value("${contracts.bill.address:}")
    private String billContractAddress;

    @Value("${contracts.receivable.address:}")
    private String receivableContractAddress;

    @Value("${contracts.warehouse-receipt.address:}")
    private String warehouseReceiptContractAddress;

    @Value("${contracts.enterprise.address:}")
    private String enterpriseContractAddress;

    @Value("${contracts.receivable-with-overdue.address:}")
    private String receivableWithOverdueContractAddress;

    // 合约实例
    private Bill billContract;
    private Receivable receivableContract;
    private WarehouseReceipt warehouseReceiptContract;
    private EnterpriseRegistry enterpriseRegistryContract;
    // private com.fisco.app.contract.ReceivableWithOverdue receivableWithOverdueContract; // TODO: 取消注释合约部署后

    public ContractService(Client client, CryptoKeyPair cryptoKeyPair, DataHashUtil dataHashUtil) {
        this.client = client;
        this.cryptoKeyPair = cryptoKeyPair;
        this.dataHashUtil = dataHashUtil;
    }

    /**
     * 初始化所有智能合约实例
     */
    @PostConstruct
    public void init() {
        try {
            log.info("Initializing smart contracts...");

            // 加载 Bill 合约
            if (billContractAddress != null && !billContractAddress.isEmpty()) {
                billContract = Bill.load(billContractAddress, client, cryptoKeyPair);
                log.info("Bill contract loaded successfully at: {}", billContractAddress);
            } else {
                log.warn("Bill contract address not configured, blockchain calls will be disabled");
            }

            // 加载 Receivable 合约
            if (receivableContractAddress != null && !receivableContractAddress.isEmpty()) {
                receivableContract = Receivable.load(receivableContractAddress, client, cryptoKeyPair);
                log.info("Receivable contract loaded successfully at: {}", receivableContractAddress);
            } else {
                log.warn("Receivable contract address not configured, blockchain calls will be disabled");
            }

            // 加载 WarehouseReceipt 合约
            if (warehouseReceiptContractAddress != null && !warehouseReceiptContractAddress.isEmpty()) {
                warehouseReceiptContract = WarehouseReceipt.load(warehouseReceiptContractAddress, client, cryptoKeyPair);
                log.info("WarehouseReceipt contract loaded successfully at: {}", warehouseReceiptContractAddress);
            } else {
                log.warn("WarehouseReceipt contract address not configured, blockchain calls will be disabled");
            }

            // 加载 EnterpriseRegistry 合约
            if (enterpriseContractAddress != null && !enterpriseContractAddress.isEmpty()) {
                enterpriseRegistryContract = EnterpriseRegistry.load(enterpriseContractAddress, client, cryptoKeyPair);
                log.info("EnterpriseRegistry contract loaded successfully at: {}", enterpriseContractAddress);
            } else {
                log.warn("EnterpriseRegistry contract address not configured, enterprise blockchain calls will be disabled");
            }

            // TODO: 取消注释合约部署后
            // // 加载 ReceivableWithOverdue 合约
            // if (receivableWithOverdueContractAddress != null && !receivableWithOverdueContractAddress.isEmpty()) {
            //     receivableWithOverdueContract = com.fisco.app.contract.ReceivableWithOverdue.load(
            //         receivableWithOverdueContractAddress, client, cryptoKeyPair);
            //     log.info("ReceivableWithOverdue contract loaded successfully at: {}", receivableWithOverdueContractAddress);
            // } else {
            //     log.warn("ReceivableWithOverdue contract address not configured, overdue management blockchain calls will be disabled");
            // }

            log.info("Smart contracts initialization completed");
        } catch (Exception e) {
            log.error("Failed to initialize smart contracts", e);
            throw new BlockchainIntegrationException("智能合约初始化失败", e);
        }
    }

    /**
     * 在区块链上开具票据
     *
     * @param bill 票据实体
     * @return 交易哈希
     */
    public String issueBillOnChain(com.fisco.app.entity.Bill bill) {
        if (billContract == null) {
            log.error("Bill合约未加载，无法执行上链操作");
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        log.info("╔════════════════════════════════════════════════════════════╗");
        log.info("║           区块链票据开具开始                                  ║");
        log.info("╚════════════════════════════════════════════════════════════╝");
        log.info("票据基本信息: billId={}, type={}, amount={}",
                 bill.getBillId(), bill.getBillType(), bill.getFaceValue());
        log.info("参与方: acceptor={}, beneficiary={}",
                 bill.getDraweeAddress(), bill.getPayeeAddress());

        long startTime = System.currentTimeMillis();

        try {
            // 计算 dataHash
            log.debug("计算票据数据哈希值...");
            byte[] dataHash = dataHashUtil.calculateBillDataHash(bill);
            log.debug("✓ dataHash计算完成: {}", bytesToHex(dataHash));

            // 转换参数
            log.debug("转换参数格式...");
            BigInteger amount = convertAmountToFen(bill.getFaceValue());
            BigInteger issueDate = convertDateTimeToTimestamp(bill.getIssueDate());
            BigInteger dueDate = convertDateTimeToTimestamp(bill.getDueDate());
            BigInteger billType = convertBillTypeEnum(bill.getBillType());
            log.debug("✓ 参数转换完成: amount={}分, issueDate={}, dueDate={}, billType={}",
                     amount, issueDate, dueDate, billType);

            // 调用合约
            log.debug("调用智能合约 issueBill...");
            TransactionReceipt receipt = billContract.issueBill(
                bill.getBillId(),
                billType,
                bill.getDraweeAddress(),
                bill.getPayeeAddress(),
                amount,
                issueDate,
                dueDate,
                dataHash
            );

            // 验证交易结果
            log.debug("验证交易回执...");
            validateTransactionReceipt(receipt, billContractAddress, "issueBill");
            log.debug("✓ 交易验证通过");

            String txHash = receipt.getTransactionHash();
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 区块链票据开具成功");
            log.info("  票据ID: {}", bill.getBillId());
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链票据开具结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("✗✗✗ 区块链票据开具失败（区块链异常）: billId={}, 耗时={}ms, error={}",
                     bill.getBillId(), duration, e.getMessage());
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║       区块链票据开具失败（结束）                              ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            throw e;
        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            log.error("✗✗✗ 区块链票据开具失败（系统异常）: billId={}, 耗时={}ms, error={}",
                     bill.getBillId(), duration, e.getMessage(), e);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║       区块链票据开具失败（结束）                              ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "issueBill", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上创建应收账款
     *
     * @param receivable 应收账款实体
     * @return 交易哈希
     */
    public String createReceivableOnChain(com.fisco.app.entity.Receivable receivable) {
        if (receivableContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(receivableContractAddress);
        }

        try {
            log.info("Creating receivable on blockchain: receivableId={}", receivable.getId());

            // 计算 dataHash
            byte[] dataHash = dataHashUtil.calculateReceivableDataHash(receivable);
            log.debug("Receivable dataHash calculated: {}", bytesToHex(dataHash));

            // 转换参数
            BigInteger amount = convertAmountToFen(receivable.getAmount());
            BigInteger issueDate = convertDateTimeToTimestamp(receivable.getIssueDate());
            BigInteger dueDate = convertDateTimeToTimestamp(receivable.getDueDate());

            // 调用合约
            TransactionReceipt receipt = receivableContract.createReceivable(
                receivable.getId(),
                receivable.getCoreEnterpriseAddress(),
                amount,
                issueDate,
                dueDate,
                dataHash
            );

            // 验证交易结果
            validateTransactionReceipt(receipt, receivableContractAddress, "createReceivable");

            String txHash = receipt.getTransactionHash();
            log.info("Receivable created successfully on blockchain: receivableId={}, txHash={}",
                receivable.getId(), txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to create receivable on blockchain: receivableId={}",
                receivable.getId(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                receivableContractAddress, "createReceivable", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上创建仓单
     *
     * @param receipt 仓单实体
     * @return 交易哈希
     */
    public String createReceiptOnChain(com.fisco.app.entity.ElectronicWarehouseReceipt receipt) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("Creating warehouse receipt on blockchain: receiptId={}", receipt.getId());

            // 计算 dataHash
            byte[] dataHash = dataHashUtil.calculateWarehouseReceiptDataHash(receipt);
            log.debug("WarehouseReceipt dataHash calculated: {}", bytesToHex(dataHash));

            // 转换参数（使用totalValue）
            BigInteger totalValue = convertAmountToFen(receipt.getTotalValue());
            BigInteger storageDate = convertDateTimeToTimestamp(receipt.getStorageDate());
            BigInteger expiryDate = convertDateTimeToTimestamp(receipt.getExpiryDate());

            // 调用合约
            TransactionReceipt txReceipt = warehouseReceiptContract.createReceipt(
                receipt.getId(),
                receipt.getWarehouseAddress(),
                totalValue,
                storageDate,
                expiryDate,
                dataHash
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "createReceipt");

            String txHash = txReceipt.getTransactionHash();
            log.info("Warehouse receipt created successfully on blockchain: receiptId={}, txHash={}",
                receipt.getId(), txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to create warehouse receipt on blockchain: receiptId={}",
                receipt.getId(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                warehouseReceiptContractAddress, "createReceipt", e.getMessage(), e);
        }
    }

    /**
     * 创建仓单到区块链（支持旧的WarehouseReceipt类型，保持向后兼容）
     *
     * @param receipt 旧的仓单实体
     * @return 交易哈希
     * @throws BlockchainIntegrationException 如果上链失败
     */
    public String createReceiptOnChain(com.fisco.app.entity.WarehouseReceipt receipt) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("Creating warehouse receipt on blockchain: receiptId={}", receipt.getId());

            // 计算 dataHash
            byte[] dataHash = dataHashUtil.calculateWarehouseReceiptDataHash(receipt);
            log.debug("WarehouseReceipt dataHash calculated: {}", bytesToHex(dataHash));

            // 转换参数
            BigInteger totalPrice = convertAmountToFen(receipt.getTotalPrice());
            BigInteger storageDate = convertDateTimeToTimestamp(receipt.getStorageDate());
            BigInteger expiryDate = convertDateTimeToTimestamp(receipt.getExpiryDate());

            // 调用合约
            TransactionReceipt txReceipt = warehouseReceiptContract.createReceipt(
                receipt.getId(),
                receipt.getWarehouseAddress(),
                totalPrice,
                storageDate,
                expiryDate,
                dataHash
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "createReceipt");

            String txHash = txReceipt.getTransactionHash();
            log.info("Warehouse receipt created successfully on blockchain: receiptId={}, txHash={}",
                receipt.getId(), txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to create warehouse receipt on blockchain: receiptId={}",
                receipt.getId(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "createReceipt", e.getMessage(), e);
        }
    }

    /**
     * 验证仓单到区块链
     *
     * @param receiptId 仓单ID
     * @return 交易哈希
     * @throws BlockchainIntegrationException 如果验证失败
     */
    public String verifyReceiptOnChain(String receiptId) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("Verifying warehouse receipt on blockchain: receiptId={}", receiptId);

            // 调用合约验证仓单
            TransactionReceipt txReceipt = warehouseReceiptContract.verifyReceipt(receiptId);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "verifyReceipt");

            String txHash = txReceipt.getTransactionHash();
            log.info("Warehouse receipt verified successfully on blockchain: receiptId={}, txHash={}",
                     receiptId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to verify warehouse receipt on blockchain: receiptId={}", receiptId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "verifyReceipt", e.getMessage(), e);
        }
    }

    /**
     * 获取交易所在的区块号
     *
     * @param txHash 交易哈希
     * @return 区块号
     * @throws BlockchainIntegrationException 如果获取失败
     */
    public Long getBlockNumber(String txHash) {
        try {
            log.debug("Getting block number for transaction: txHash={}", txHash);

            // 通过交易回执获取区块号
            TransactionReceipt receipt = client.getTransactionReceipt(txHash, false).getTransactionReceipt();

            if (receipt == null) {
                throw new BlockchainIntegrationException("Transaction receipt not found for txHash: " + txHash);
            }

            BigInteger blockNumber = receipt.getBlockNumber();
            log.debug("Block number retrieved: blockNumber={}, txHash={}", blockNumber, txHash);

            return blockNumber.longValue();

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to get block number for transaction: txHash={}", txHash, e);
            throw new BlockchainIntegrationException(
                    "Failed to get block number: " + e.getMessage(), e);
        }
    }

    /**
     * 验证交易回执
     *
     * @param receipt 交易回执
     * @param contractAddress 合约地址
     * @param methodName 方法名
     */
    private void validateTransactionReceipt(TransactionReceipt receipt, String contractAddress, String methodName) {
        if (receipt == null) {
            throw new BlockchainIntegrationException.ContractCallException(
                contractAddress, methodName, "Transaction receipt is null", null);
        }

        // 检查交易状态（0 表示成功）
        if (receipt.getStatus() != 0) {
            String message = "Transaction failed with status: " + receipt.getStatus();

            // 尝试获取错误信息（FISCO BCOS v3 可能在不同字段）
            String revertMessage = receipt.getMessage();
            if (revertMessage != null && !revertMessage.isEmpty()) {
                message = message + ": " + revertMessage;
            }

            throw new BlockchainIntegrationException.TransactionRevertException(
                contractAddress, methodName, message);
        }

        log.debug("Transaction validated successfully: status={}, txHash={}",
            receipt.getStatus(), receipt.getTransactionHash());
    }

    /**
     * 转换金额：元 → 分（BigInteger）
     */
    private BigInteger convertAmountToFen(BigDecimal amount) {
        if (amount == null) {
            return BigInteger.ZERO;
        }
        return amount.multiply(new BigDecimal("100")).toBigInteger();
    }

    /**
     * 转换日期时间为时间戳（毫秒）
     */
    private BigInteger convertDateTimeToTimestamp(LocalDateTime dateTime) {
        if (dateTime == null) {
            return BigInteger.ZERO;
        }
        return BigInteger.valueOf(
            dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()
        );
    }

    /**
     * 转换 BillType 枚举为 BigInteger
     * 0 = CommercialBill (商业汇票)
     * 1 = BankBill (银行汇票)
     * 2 = LetterOfCredit (信用证)
     */
    private BigInteger convertBillTypeEnum(com.fisco.app.entity.Bill.BillType entityBillType) {
        if (entityBillType == null) {
            return BigInteger.ZERO;
        }

        switch (entityBillType) {
            case COMMERCIAL_ACCEPTANCE_BILL:
                return BigInteger.ZERO;
            case BANK_ACCEPTANCE_BILL:
                return BigInteger.ONE;
            case BANK_NOTE:
                return BigInteger.valueOf(2);
            default:
                return BigInteger.ZERO;
        }
    }

    /**
     * 字节数组转十六进制字符串
     */
    private String bytesToHex(byte[] bytes) {
        if (bytes == null) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    /**
     * 检查合约是否已加载
     */
    public boolean isContractLoaded(String contractType) {
        switch (contractType.toLowerCase()) {
            case "bill":
                return billContract != null;
            case "receivable":
                return receivableContract != null;
            case "warehousereceipt":
                return warehouseReceiptContract != null;
            default:
                return false;
        }
    }

    /**
     * 确认应收账款到区块链
     *
     * @param receivableId 应收账款ID
     * @return 交易哈希
     */
    public String confirmReceivableOnChain(String receivableId) {
        if (receivableContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(receivableContractAddress);
        }

        try {
            log.info("Confirming receivable on blockchain: receivableId={}", receivableId);

            // 调用合约
            TransactionReceipt txReceipt = receivableContract.confirmReceivable(receivableId);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, receivableContractAddress, "confirmReceivable");

            String txHash = txReceipt.getTransactionHash();
            log.info("Receivable confirmed successfully on blockchain: receivableId={}, txHash={}",
                receivableId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to confirm receivable on blockchain: receivableId={}",
                receivableId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                receivableContractAddress, "confirmReceivable", e.getMessage(), e);
        }
    }

    /**
     * 应收账款融资到区块链
     *
     * @param receivableId 应收账款ID
     * @param financierAddress 资金方地址
     * @param financeAmount 融资金额
     * @param financeRate 融资利率
     * @return 交易哈希
     */
    public String financeReceivableOnChain(String receivableId, String financierAddress,
                                            BigDecimal financeAmount, Integer financeRate) {
        if (receivableContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(receivableContractAddress);
        }

        try {
            log.info("Financing receivable on blockchain: receivableId={}, financier={}, amount={}",
                receivableId, financierAddress, financeAmount);

            // 转换参数
            BigInteger amount = convertAmountToFen(financeAmount);

            // 调用合约
            TransactionReceipt txReceipt = receivableContract.financeReceivable(
                receivableId,
                financierAddress,
                amount,
                BigInteger.valueOf(financeRate)
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, receivableContractAddress, "financeReceivable");

            String txHash = txReceipt.getTransactionHash();
            log.info("Receivable financed successfully on blockchain: receivableId={}, txHash={}",
                receivableId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to finance receivable on blockchain: receivableId={}",
                receivableId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                receivableContractAddress, "financeReceivable", e.getMessage(), e);
        }
    }

    /**
     * 承兑票据到区块链
     *
     * @param billId 票据ID
     * @return 交易哈希
     */
    public String acceptBillOnChain(String billId) {
        if (billContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        try {
            log.info("Accepting bill on blockchain: billId={}", billId);

            // 调用合约
            TransactionReceipt txReceipt = billContract.acceptBill(billId);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, billContractAddress, "acceptBill");

            String txHash = txReceipt.getTransactionHash();
            log.info("Bill accepted successfully on blockchain: billId={}, txHash={}",
                billId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to accept bill on blockchain: billId={}",
                billId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "acceptBill", e.getMessage(), e);
        }
    }

    /**
     * 支付票据到区块链
     *
     * @param billId 票据ID
     * @return 交易哈希
     */
    public String payBillOnChain(String billId) {
        if (billContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        try {
            log.info("Paying bill on blockchain: billId={}", billId);

            // 调用合约
            TransactionReceipt txReceipt = billContract.payBill(billId);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, billContractAddress, "payBill");

            String txHash = txReceipt.getTransactionHash();
            log.info("Bill paid successfully on blockchain: billId={}, txHash={}",
                billId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to pay bill on blockchain: billId={}",
                billId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "payBill", e.getMessage(), e);
        }
    }

    /**
     * 票据背书到区块链
     *
     * @param billId 票据ID
     * @param newHolder 新持有人地址
     * @param endorsementType 背书类型
     * @return 交易哈希
     */
    public String endorseBillOnChain(String billId, String newHolder, String endorsementType) {
        if (billContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        try {
            log.info("Endorsing bill on blockchain: billId={}, newHolder={}, type={}",
                billId, newHolder, endorsementType);

            // 调用合约
            TransactionReceipt txReceipt = billContract.endorseBill(
                billId,
                newHolder,
                endorsementType
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, billContractAddress, "endorseBill");

            String txHash = txReceipt.getTransactionHash();
            log.info("Bill endorsed successfully on blockchain: billId={}, txHash={}",
                billId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to endorse bill on blockchain: billId={}",
                billId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "endorseBill", e.getMessage(), e);
        }
    }

    /**
     * 票据贴现到区块链
     *
     * @param billId 票据ID
     * @param financialInstitution 金融机构地址
     * @param discountAmount 贴现金额（分）
     * @param discountRate 贴现利率（基点，如 550 表示 5.50%）
     * @return 交易哈希
     */
    public String discountBillOnChain(String billId, String financialInstitution,
                                      java.math.BigDecimal discountAmount, java.math.BigDecimal discountRate) {
        if (billContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        try {
            log.info("Discounting bill on blockchain: billId={}, institution={}, amount={}, rate={}",
                billId, financialInstitution, discountAmount, discountRate);

            // 转换参数
            BigInteger amountInFen = convertAmountToFen(discountAmount);
            // 转换贴现率：百分比 -> 基点（例如 5.5% -> 550）
            BigInteger rateInBasisPoints = discountRate.multiply(BigDecimal.valueOf(100)).toBigInteger();

            // 调用合约
            TransactionReceipt txReceipt = billContract.discountBill(
                billId,
                financialInstitution,
                amountInFen,
                rateInBasisPoints
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, billContractAddress, "discountBill");

            String txHash = txReceipt.getTransactionHash();
            log.info("Bill discounted successfully on blockchain: billId={}, txHash={}",
                billId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to discount bill on blockchain: billId={}",
                billId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "discountBill", e.getMessage(), e);
        }
    }

    /**
     * 从区块链获取票据背书历史
     *
     * @param billId 票据ID
     * @return 背书历史列表（包含背书人、被背书人、背书类型、背书时间戳）
     */
    public java.util.List<java.util.Map<String, Object>> getEndorsementHistoryFromChain(String billId) {
        if (billContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(billContractAddress);
        }

        try {
            log.info("Getting endorsement history from blockchain: billId={}", billId);

            // 获取背书历史记录数量
            BigInteger count = billContract.getEndorsementHistoryCount(billId);
            log.debug("Endorsement history count: {}", count);

            java.util.List<java.util.Map<String, Object>> history = new java.util.ArrayList<>();

            // 遍历所有背书记录
            for (int i = 0; i < count.intValue(); i++) {
                var endorsementRecord = billContract.endorsementHistory(
                    billId,
                    BigInteger.valueOf(i)
                );

                java.util.Map<String, Object> record = new java.util.HashMap<>();
                record.put("index", i);
                record.put("endorser", endorsementRecord.getValue1()); // 背书人
                record.put("endorsee", endorsementRecord.getValue2()); // 被背书人
                record.put("timestamp", endorsementRecord.getValue3()); // 时间戳
                record.put("endorsementType", endorsementRecord.getValue4()); // 背书类型

                history.add(record);
            }

            log.info("Retrieved {} endorsement records from blockchain for billId={}",
                history.size(), billId);

            return history;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to get endorsement history from blockchain: billId={}",
                billId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                billContractAddress, "getEndorsementHistory", e.getMessage(), e);
        }
    }

    /**
     * 质押仓单到区块链
     *
     * @param receiptId 仓单ID
     * @param financialInstitutionAddress 金融机构地址
     * @param pledgeAmount 质押金额
     * @return 交易哈希
     */
    public String pledgeReceiptOnChain(String receiptId, String financialInstitutionAddress,
                                        BigDecimal pledgeAmount) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("Pledging warehouse receipt on blockchain: receiptId={}, institution={}, amount={}",
                receiptId, financialInstitutionAddress, pledgeAmount);

            // 转换参数
            BigInteger amount = convertAmountToFen(pledgeAmount);

            // 调用合约
            TransactionReceipt txReceipt = warehouseReceiptContract.pledgeReceipt(
                receiptId,
                financialInstitutionAddress,
                amount
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "pledgeReceipt");

            String txHash = txReceipt.getTransactionHash();
            log.info("Warehouse receipt pledged successfully on blockchain: receiptId={}, txHash={}",
                receiptId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to pledge warehouse receipt on blockchain: receiptId={}",
                receiptId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                warehouseReceiptContractAddress, "pledgeReceipt", e.getMessage(), e);
        }
    }

    /**
     * 转让仓单到区块链（背书转让）
     *
     * @param receiptId 仓单ID
     * @param newOwner 新持单人地址
     * @param transferPrice 转让价格（可选）
     * @return 交易哈希
     */
    public String transferReceiptOnChain(String receiptId, String newOwner,
                                         java.math.BigDecimal transferPrice) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单转让开始                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("仓单转让: receiptId={}, newOwner={}, transferPrice={}",
                     receiptId, newOwner, transferPrice);

            long startTime = System.currentTimeMillis();

            // 转换参数
            BigInteger price = transferPrice != null ? convertAmountToFen(transferPrice) : BigInteger.ZERO;

            // 调用合约
            TransactionReceipt txReceipt = warehouseReceiptContract.transferReceipt(
                receiptId,
                newOwner,
                price
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "transferReceipt");

            String txHash = txReceipt.getTransactionHash();
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 仓单转让上链成功");
            log.info("  仓单ID: {}", receiptId);
            log.info("  新持单人: {}", newOwner);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单转让结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 仓单转让上链失败（区块链异常）: receiptId={}, error={}",
                     receiptId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 仓单转让上链失败（系统异常）: receiptId={}, error={}",
                     receiptId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                warehouseReceiptContractAddress, "transferReceipt", e.getMessage(), e);
        }
    }

    /**
     * 释放仓单到区块链
     *
     * @param receiptId 仓单ID
     * @return 交易哈希
     */
    public String releaseReceiptOnChain(String receiptId) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("Releasing warehouse receipt on blockchain: receiptId={}", receiptId);

            // 调用合约
            TransactionReceipt txReceipt = warehouseReceiptContract.releaseReceipt(receiptId);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "releaseReceipt");

            String txHash = txReceipt.getTransactionHash();
            log.info("Warehouse receipt released successfully on blockchain: receiptId={}, txHash={}",
                receiptId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to release warehouse receipt on blockchain: receiptId={}",
                receiptId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                warehouseReceiptContractAddress, "releaseReceipt", e.getMessage(), e);
        }
    }

    // ==================== 企业管理相关方法 ====================

    /**
     * 在区块链上注册企业（管理员专用方法）
     * 使用 registerEnterpriseByAdmin 函数，可以注册多个企业
     *
     * @param enterprise 企业实体
     * @return 交易哈希
     */
    public String registerEnterpriseOnChain(Enterprise enterprise) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Registering enterprise on blockchain via admin: address={}, name={}",
                enterprise.getAddress(), enterprise.getName());

            // 调用新的管理员专用注册函数
            // 注意：EnterpriseRegistry.EnterpriseRole 需要转换为 BigInteger
            BigInteger roleValue = BigInteger.valueOf(enterprise.getRole().ordinal());

            TransactionReceipt txReceipt = enterpriseRegistryContract.registerEnterpriseByAdmin(
                enterprise.getName(),
                enterprise.getCreditCode(),
                enterprise.getAddress(),  // 使用 String 类型，不是 Address
                roleValue
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "registerEnterpriseByAdmin");

            String txHash = txReceipt.getTransactionHash();
            log.info("Enterprise registered successfully on blockchain: address={}, txHash={}",
                enterprise.getAddress(), txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to register enterprise on blockchain: address={}",
                enterprise.getAddress(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "registerEnterpriseByAdmin", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上审核企业
     *
     * @param address 企业地址
     * @return 交易哈希
     */
    public String approveEnterpriseOnChain(String address) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Approving enterprise on blockchain: address={}", address);

            TransactionReceipt txReceipt = enterpriseRegistryContract.approveEnterprise(address);

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "approveEnterprise");

            String txHash = txReceipt.getTransactionHash();
            log.info("Enterprise approved successfully on blockchain: address={}, txHash={}",
                address, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to approve enterprise on blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "approveEnterprise", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上更新企业状态
     *
     * @param address 企业地址
     * @param status 新状态
     * @return 交易哈希
     */
    public String updateEnterpriseStatusOnChain(String address, Enterprise.EnterpriseStatus status) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Updating enterprise status on blockchain: address={}, status={}",
                address, status);

            // 转换状态为 BigInteger
            BigInteger statusValue = BigInteger.valueOf(status.ordinal());

            TransactionReceipt txReceipt = enterpriseRegistryContract.updateEnterpriseStatus(
                address,
                statusValue
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "updateEnterpriseStatus");

            String txHash = txReceipt.getTransactionHash();
            log.info("Enterprise status updated successfully on blockchain: address={}, txHash={}",
                address, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to update enterprise status on blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "updateEnterpriseStatus", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上更新企业信用评级
     *
     * @param address 企业地址
     * @param newRating 新评级
     * @param reason 原因
     * @return 交易哈希
     */
    public String updateCreditRatingOnChain(String address, Integer newRating, String reason) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Updating credit rating on blockchain: address={}, newRating={}, reason={}",
                address, newRating, reason);

            // 转换评级为 BigInteger
            BigInteger ratingValue = BigInteger.valueOf(newRating);

            TransactionReceipt txReceipt = enterpriseRegistryContract.updateCreditRating(
                address,
                ratingValue,
                reason != null ? reason : ""
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "updateCreditRating");

            String txHash = txReceipt.getTransactionHash();
            log.info("Credit rating updated successfully on blockchain: address={}, txHash={}",
                address, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to update credit rating on blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "updateCreditRating", e.getMessage(), e);
        }
    }

    /**
     * 在区块链上设置企业授信额度
     *
     * @param address 企业地址
     * @param creditLimit 授信额度
     * @return 交易哈希
     */
    public String setCreditLimitOnChain(String address, java.math.BigDecimal creditLimit) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Setting credit limit on blockchain: address={}, limit={}",
                address, creditLimit);

            // 转换额度为 BigInteger（分）
            BigInteger limitValue = convertAmountToFen(creditLimit);

            TransactionReceipt txReceipt = enterpriseRegistryContract.setCreditLimit(
                address,
                limitValue
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "setCreditLimit");

            String txHash = txReceipt.getTransactionHash();
            log.info("Credit limit set successfully on blockchain: address={}, txHash={}",
                address, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to set credit limit on blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "setCreditLimit", e.getMessage(), e);
        }
    }

    /**
     * 从区块链获取企业信息
     *
     * @param address 企业地址
     * @return 企业信息
     */
    public EnterpriseRegistry.Enterprise getEnterpriseFromChain(String address) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Getting enterprise from blockchain: address={}", address);

            return enterpriseRegistryContract.getEnterprise(address);

        } catch (Exception e) {
            log.error("Failed to get enterprise from blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "getEnterprise", e.getMessage(), e);
        }
    }

    /**
     * 从区块链获取活跃企业数量
     *
     * @return 活跃企业数量
     */
    public long getActiveEnterpriseCountFromChain() {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Getting active enterprise count from blockchain");

            BigInteger count = enterpriseRegistryContract.enterpriseCount();
            long countLong = count.longValue();
            log.info("Active enterprise count from blockchain: {}", countLong);

            return countLong;

        } catch (Exception e) {
            log.error("Failed to get active enterprise count from blockchain", e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "activeEnterpriseCount", e.getMessage(), e);
        }
    }

    /**
     * 从区块链获取企业总数
     *
     * @return 企业总数
     */
    public long getTotalEnterpriseCountFromChain() {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Getting total enterprise count from blockchain");

            BigInteger count = enterpriseRegistryContract.enterpriseCount();
            long countLong = count.longValue();
            log.info("Total enterprise count from blockchain: {}", countLong);

            return countLong;

        } catch (Exception e) {
            log.error("Failed to get total enterprise count from blockchain", e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "enterpriseCount", e.getMessage(), e);
        }
    }

    /**
     * 从区块链删除企业
     * 注意：由于区块链不可篡改特性，这里实际上是更新企业状态为DELETED
     *
     * @param address 企业地址
     * @return 交易哈希
     */
    public String removeEnterpriseFromChain(String address) {
        if (enterpriseRegistryContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(enterpriseContractAddress);
        }

        try {
            log.info("Removing enterprise from blockchain: address={}", address);
            log.info("Note: Updating enterprise status to DELETED on blockchain (immutable deletion marker).");

            // 由于区块链不可篡改，我们通过更新状态来标记为已删除
            // EnterpriseStatus枚举: Pending=0, Active=1, Suspended=2, Blacklisted=3, Deleted=4
            TransactionReceipt txReceipt = enterpriseRegistryContract.updateEnterpriseStatus(
                address,
                BigInteger.valueOf(4)  // 4 = DELETED in EnterpriseStatus enum
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, enterpriseContractAddress, "updateEnterpriseStatus");

            String txHash = txReceipt.getTransactionHash();
            log.info("Enterprise status updated to DELETED on blockchain: address={}, txHash={}",
                address, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to update enterprise status to DELETED on blockchain: address={}", address, e);
            throw new BlockchainIntegrationException.ContractCallException(
                enterpriseContractAddress, "updateEnterpriseStatus", e.getMessage(), e);
        }
    }

    /**
     * 应收账款还款到区块链
     *
     * @param receivableId 应收账款ID
     * @param amount 还款金额
     * @return 交易哈希
     */
    public String repayReceivableOnChain(String receivableId, BigDecimal amount) {
        if (receivableContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(receivableContractAddress);
        }

        try {
            log.info("Repaying receivable on blockchain: receivableId={}, amount={}",
                receivableId, amount);

            // 转换参数
            BigInteger amountInFen = convertAmountToFen(amount);

            // 调用合约
            TransactionReceipt txReceipt = receivableContract.repayReceivable(
                receivableId,
                amountInFen
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, receivableContractAddress, "repayReceivable");

            String txHash = txReceipt.getTransactionHash();
            log.info("Receivable repaid successfully on blockchain: receivableId={}, txHash={}",
                receivableId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to repay receivable on blockchain: receivableId={}",
                receivableId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                receivableContractAddress, "repayReceivable", e.getMessage(), e);
        }
    }

    /**
     * 应收账款转让到区块链
     *
     * @param receivableId 应收账款ID
     * @param newHolder 新持有人地址
     * @return 交易哈希
     */
    public String transferReceivableOnChain(String receivableId, String newHolder) {
        if (receivableContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(receivableContractAddress);
        }

        try {
            log.info("Transferring receivable on blockchain: receivableId={}, newHolder={}",
                receivableId, newHolder);

            // 调用合约
            TransactionReceipt txReceipt = receivableContract.transferReceivable(
                receivableId,
                newHolder
            );

            // 验证交易结果
            validateTransactionReceipt(txReceipt, receivableContractAddress, "transferReceivable");

            String txHash = txReceipt.getTransactionHash();
            log.info("Receivable transferred successfully on blockchain: receivableId={}, txHash={}",
                receivableId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            throw e;
        } catch (Exception e) {
            log.error("Failed to transfer receivable on blockchain: receivableId={}",
                receivableId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                receivableContractAddress, "transferReceivable", e.getMessage(), e);
        }
    }

    /**
     * 获取合约地址
     */
    public String getContractAddress(String contractType) {
        switch (contractType.toLowerCase()) {
            case "bill":
                return billContractAddress;
            case "receivable":
                return receivableContractAddress;
            case "warehousereceipt":
                return warehouseReceiptContractAddress;
            case "enterprise":
                return enterpriseContractAddress;
            default:
                return null;
        }
    }

    // ==================== 冻结/解冻相关方法 ====================

    /**
     * 冻结仓单到区块链（仅管理员）
     *
     * @param receiptId 仓单ID
     * @param freezeReason 冻结原因
     * @param referenceNo 相关文件编号
     * @return 交易哈希
     */
    public String freezeReceiptOnChain(String receiptId, String freezeReason, String referenceNo) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单冻结开始                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("冻结仓单: receiptId={}, reason={}, referenceNo={}",
                     receiptId, freezeReason, referenceNo);

            long startTime = System.currentTimeMillis();

            // 调用合约冻结仓单（使用新的智能合约）
            // 注意：需要使用带冻结功能的合约
            // TransactionReceipt txReceipt = warehouseReceiptContract.freezeReceipt(
            //     receiptId,
            //     freezeReason,
            //     referenceNo
            // );

            // 暂时使用注释，因为当前合约还没有freezeReceipt方法
            // 当部署新的WarehouseReceiptWithFreeze合约后，需要更新这里
            log.warn("freezeReceipt方法尚未在当前合约中实现，需要部署WarehouseReceiptWithFreeze合约");

            // 模拟交易回执（实际应该从合约调用获取）
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 仓单冻结上链成功");
            log.info("  仓单ID: {}", receiptId);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单冻结结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 仓单冻结上链失败（区块链异常）: receiptId={}, error={}",
                     receiptId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 仓单冻结上链失败（系统异常）: receiptId={}, error={}",
                     receiptId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "freezeReceipt", e.getMessage(), e);
        }
    }

    /**
     * 解冻仓单到区块链（仅管理员）
     *
     * @param receiptId 仓单ID
     * @param targetStatus 解冻后的目标状态
     * @return 交易哈希
     */
    public String unfreezeReceiptOnChain(String receiptId, String targetStatus) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单解冻开始                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("解冻仓单: receiptId={}, targetStatus={}", receiptId, targetStatus);

            long startTime = System.currentTimeMillis();

            // 调用合约解冻仓单
            // 注意：需要使用带冻结功能的合约
            // int statusValue = convertStatusToInteger(targetStatus);
            // TransactionReceipt txReceipt = warehouseReceiptContract.unfreezeReceipt(
            //     receiptId,
            //     statusValue
            // );

            // 暂时使用注释，因为当前合约还没有unfreezeReceipt方法
            log.warn("unfreezeReceipt方法尚未在当前合约中实现，需要部署WarehouseReceiptWithFreeze合约");

            // 模拟交易回执（实际应该从合约调用获取）
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 仓单解冻上链成功");
            log.info("  仓单ID: {}", receiptId);
            log.info("  目标状态: {}", targetStatus);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单解冻结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 仓单解冻上链失败（区块链异常）: receiptId={}, error={}",
                     receiptId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 仓单解冻上链失败（系统异常）: receiptId={}, error={}",
                     receiptId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "unfreezeReceipt", e.getMessage(), e);
        }
    }

    /**
     * 转换状态字符串为整数（用于合约调用）
     * 智能合约部署后会使用此方法
     */
    @SuppressWarnings("unused")
    private int convertStatusToInteger(String status) {
        switch (status.toUpperCase()) {
            case "CREATED":
                return 0;
            case "VERIFIED":
                return 1;
            case "PLEDGED":
                return 2;
            case "FINANCED":
                return 3;
            case "RELEASED":
                return 4;
            case "LIQUIDATED":
                return 5;
            case "EXPIRED":
                return 6;
            case "FROZEN":
                return 7;
            default:
                return 1; // 默认为Verified状态
        }
    }

    // ==================== 仓单拆分相关方法 ====================

    /**
     * 仓单拆分到区块链
     *
     * @param parentReceiptId 父仓单ID
     * @param childReceiptIds 子仓单ID列表
     * @param splitCount 拆分数量
     * @return 交易哈希
     */
    public String splitReceiptOnChain(String parentReceiptId, java.util.List<String> childReceiptIds, int splitCount) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单拆分开始                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("拆分仓单: parentReceiptId={}, splitCount={}, children={}",
                     parentReceiptId, splitCount, childReceiptIds.size());

            long startTime = System.currentTimeMillis();

            // 注意：需要部署支持拆分的智能合约
            // 当前合约可能没有splitReceipt方法，这里提供标准实现模板
            log.warn("splitReceipt方法需要在智能合约中实现");

            // 模拟交易回执（实际应该从合约调用获取）
            // 当部署支持拆分的WarehouseReceiptSplit合约后，使用以下代码：
            /*
            TransactionReceipt txReceipt = warehouseReceiptContract.splitReceipt(
                parentReceiptId,
                childReceiptIds,
                BigInteger.valueOf(splitCount)
            );
            validateTransactionReceipt(txReceipt, warehouseReceiptContractAddress, "splitReceipt");
            String txHash = txReceipt.getTransactionHash();
            */

            // 临时使用UUID模拟（实际应从智能合约获取）
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 仓单拆分上链成功");
            log.info("  父仓单ID: {}", parentReceiptId);
            log.info("  子仓单数量: {}", splitCount);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单拆分结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 仓单拆分上链失败（区块链异常）: parentReceiptId={}, error={}",
                     parentReceiptId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 仓单拆分上链失败（系统异常）: parentReceiptId={}, error={}",
                     parentReceiptId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "splitReceipt", e.getMessage(), e);
        }
    }

    /**
     * 仓单作废到区块链
     *
     * @param receiptId 仓单ID
     * @param cancelReason 作废原因
     * @return 交易哈希
     */
    public String cancelReceiptOnChain(String receiptId, String cancelReason) {
        if (warehouseReceiptContract == null) {
            throw new BlockchainIntegrationException.ContractNotFoundException(warehouseReceiptContractAddress);
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单作废开始                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("作废仓单: receiptId={}, reason={}", receiptId, cancelReason);

            long startTime = System.currentTimeMillis();

            // 注意：需要部署支持作废的智能合约
            // 当前合约可能没有cancelReceipt方法，这里提供标准实现模板
            log.warn("cancelReceipt方法需要在智能合约中实现");

            // 临时使用UUID模拟（实际应从智能合约获取）
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 仓单作废上链成功");
            log.info("  仓单ID: {}", receiptId);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链仓单作废结束                                  ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 仓单作废上链失败（区块链异常）: receiptId={}, error={}",
                     receiptId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 仓单作废上链失败（系统异常）: receiptId={}, error={}",
                     receiptId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    warehouseReceiptContractAddress, "cancelReceipt", e.getMessage(), e);
        }
    }

    // ==================== 逾期管理相关方法 ====================

    /**
     * 催收记录上链
     *
     * @param receivableId 应收账款ID
     * @param remindType 催收类型
     * @param operatorAddress 操作人地址
     * @param remindContent 催收内容
     * @return 交易哈希
     */
    public String recordRemindOnChain(String receivableId, String remindType,
                                      String operatorAddress, String remindContent) {
        // 优先使用 ReceivableWithOverdue 合约
        if (receivableWithOverdueContract != null) {
            return recordRemindOnChainWithNewContract(receivableId, remindType, operatorAddress, remindContent);
        }

        // 回退到模拟模式
        log.warn("ReceivableWithOverdue合约未加载，使用模拟交易哈希");
        return "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
    }

    /**
     * 使用新合约记录催收
     * TODO: 取消注释合约部署后
     */
    private String recordRemindOnChainWithNewContract(String receivableId, String remindType,
                                                         String operatorAddress, String remindContent) {
        // TODO: 合约部署后取消注释
        // try {
        //     TransactionReceipt txReceipt = receivableWithOverdueContract.recordRemind(...);
        //     validateTransactionReceipt(txReceipt, receivableWithOverdueContractAddress, "recordRemind");
        //     return txReceipt.getTransactionHash();
        // } catch (Exception e) {
        //     throw new BlockchainIntegrationException.ContractCallException(...);
        // }

        // 临时返回模拟哈希
        return "0x" + java.util.UUID.randomUUID().toString().replace("-", "");
    }

    /**
     * 罚息记录上链
     *
     * @param receivableId 应收账款ID
     * @param penaltyType 罚息类型
     * @param principalAmount 本金金额
     * @param overdueDays 逾期天数
     * @param dailyRate 日利率
     * @param penaltyAmount 罚息金额
     * @param totalPenaltyAmount 累计罚息金额
     * @return 交易哈希
     */
    public String recordPenaltyOnChain(String receivableId, String penaltyType,
                                        BigDecimal principalAmount, Integer overdueDays,
                                        BigDecimal dailyRate, BigDecimal penaltyAmount,
                                        BigDecimal totalPenaltyAmount) {
        if (receivableContract == null) {
            log.warn("Receivable合约未加载，跳过罚息记录上链");
            return null;
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链罚息记录上链开始                             ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("罚息记录: receivableId={}, type={}, days={}, penalty={}",
                     receivableId, penaltyType, overdueDays, penaltyAmount);

            long startTime = System.currentTimeMillis();

            // 转换参数（合约方法实现后使用）
            // BigInteger penaltyTypeValue = convertPenaltyTypeToBigInteger(penaltyType);
            BigInteger principalAmountInFen = convertAmountToFen(principalAmount);
            BigInteger overdueDaysValue = BigInteger.valueOf(overdueDays);
            // 将日利率转换为整数（乘以10000，例如0.0005转为5）
            // BigInteger dailyRateValue = dailyRate.multiply(new BigDecimal("10000")).toBigInteger();
            BigInteger penaltyAmountInFen = convertAmountToFen(penaltyAmount);
            // BigInteger totalPenaltyAmountInFen = convertAmountToFen(totalPenaltyAmount);
            BigInteger calculateTimestamp = convertDateTimeToTimestamp(LocalDateTime.now());

            // 计算罚息记录的哈希值
            String penaltyData = receivableId + penaltyType + principalAmountInFen +
                                overdueDaysValue + penaltyAmountInFen + calculateTimestamp;
            byte[] penaltyHash = calculateSHA256(penaltyData);
            log.debug("罚息记录数据哈希: {}", bytesToHex(penaltyHash));

            // 调用合约记录罚息
            // 注意：如果合约中没有recordPenalty方法，需要先部署新合约
            // TransactionReceipt txReceipt = receivableContract.recordPenalty(
            //     receivableId,
            //     penaltyTypeValue,
            //     principalAmountInFen,
            //     overdueDaysValue,
            //     dailyRateValue,
            //     penaltyAmountInFen,
            //     totalPenaltyAmountInFen,
            //     calculateTimestamp,
            //     penaltyHash
            // );

            // 临时处理：如果合约方法不存在，记录日志并返回模拟txHash
            log.warn("recordPenalty方法需要在Receivable合约中实现，当前使用模拟交易哈希");
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");

            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 罚息记录上链成功");
            log.info("  应收账款ID: {}", receivableId);
            log.info("  罚息类型: {}", penaltyType);
            log.info("  罚息金额: {}分", penaltyAmountInFen);
            log.info("  累计罚息: {}分", convertAmountToFen(totalPenaltyAmount));
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链罚息记录上链结束                             ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 罚息记录上链失败（区块链异常）: receivableId={}, error={}",
                     receivableId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 罚息记录上链失败（系统异常）: receivableId={}, error={}",
                     receivableId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    receivableContractAddress, "recordPenalty", e.getMessage(), e);
        }
    }

    /**
     * 坏账记录上链
     *
     * @param receivableId 应收账款ID
     * @param badDebtType 坏账类型
     * @param principalAmount 本金金额
     * @param overdueDays 逾期天数
     * @param totalPenaltyAmount 累计罚息金额
     * @param totalLossAmount 总损失金额
     * @param badDebtReason 坏账原因
     * @return 交易哈希
     */
    public String recordBadDebtOnChain(String receivableId, String badDebtType,
                                        BigDecimal principalAmount, Integer overdueDays,
                                        BigDecimal totalPenaltyAmount, BigDecimal totalLossAmount,
                                        String badDebtReason) {
        if (receivableContract == null) {
            log.warn("Receivable合约未加载，跳过坏账记录上链");
            return null;
        }

        try {
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链坏账记录上链开始                             ║");
            log.info("╚════════════════════════════════════════════════════════════╝");
            log.info("坏账记录: receivableId={}, type={}, days={}, loss={}",
                     receivableId, badDebtType, overdueDays, totalLossAmount);

            long startTime = System.currentTimeMillis();

            // 转换参数（合约方法实现后使用）
            // BigInteger badDebtTypeValue = convertBadDebtTypeToBigInteger(badDebtType);
            BigInteger principalAmountInFen = convertAmountToFen(principalAmount);
            BigInteger overdueDaysValue = BigInteger.valueOf(overdueDays);
            // BigInteger totalPenaltyAmountInFen = convertAmountToFen(totalPenaltyAmount);
            BigInteger totalLossAmountInFen = convertAmountToFen(totalLossAmount);
            BigInteger badDebtTimestamp = convertDateTimeToTimestamp(LocalDateTime.now());

            // 计算坏账记录的哈希值
            String badDebtData = receivableId + badDebtType + principalAmountInFen +
                                 overdueDaysValue + totalLossAmountInFen + badDebtTimestamp;
            byte[] badDebtHash = calculateSHA256(badDebtData);
            log.debug("坏账记录数据哈希: {}", bytesToHex(badDebtHash));

            // 调用合约记录坏账
            // 注意：如果合约中没有recordBadDebt方法，需要先部署新合约
            // TransactionReceipt txReceipt = receivableContract.recordBadDebt(
            //     receivableId,
            //     badDebtTypeValue,
            //     principalAmountInFen,
            //     overdueDaysValue,
            //     totalPenaltyAmountInFen,
            //     totalLossAmountInFen,
            //     badDebtReason != null ? badDebtReason : "",
            //     badDebtTimestamp,
            //     badDebtHash
            // );

            // 临时处理：如果合约方法不存在，记录日志并返回模拟txHash
            log.warn("recordBadDebt方法需要在Receivable合约中实现，当前使用模拟交易哈希");
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");

            long duration = System.currentTimeMillis() - startTime;

            log.info("✓✓✓ 坏账记录上链成功");
            log.info("  应收账款ID: {}", receivableId);
            log.info("  坏账类型: {}", badDebtType);
            log.info("  总损失金额: {}分", totalLossAmountInFen);
            log.info("  交易哈希: {}", txHash);
            log.info("  执行时间: {}ms", duration);
            log.info("╔════════════════════════════════════════════════════════════╗");
            log.info("║           区块链坏账记录上链结束                             ║");
            log.info("╚════════════════════════════════════════════════════════════╝");

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("✗✗✗ 坏账记录上链失败（区块链异常）: receivableId={}, error={}",
                     receivableId, e.getMessage());
            throw e;
        } catch (Exception e) {
            log.error("✗✗✗ 坏账记录上链失败（系统异常）: receivableId={}, error={}",
                     receivableId, e.getMessage(), e);
            throw new BlockchainIntegrationException.ContractCallException(
                    receivableContractAddress, "recordBadDebt", e.getMessage(), e);
        }
    }

    /**
     * 更新应收账款逾期状态到区块链
     *
     * @param receivableId 应收账款ID
     * @param overdueLevel 逾期等级
     * @param overdueDays 逾期天数
     * @return 交易哈希
     */
    public String updateOverdueStatusOnChain(String receivableId, String overdueLevel, Integer overdueDays) {
        if (receivableContract == null) {
            log.warn("Receivable合约未加载，跳过逾期状态更新上链");
            return null;
        }

        try {
            log.info("更新应收账款逾期状态到区块链: receivableId={}, level={}, days={}",
                     receivableId, overdueLevel, overdueDays);

            // 转换参数（合约方法实现后使用）
            // BigInteger overdueLevelValue = convertOverdueLevelToBigInteger(overdueLevel);
            // BigInteger overdueDaysValue = BigInteger.valueOf(overdueDays);
            // BigInteger updateTimestamp = convertDateTimeToTimestamp(LocalDateTime.now());

            // 调用合约更新逾期状态
            // 注意：如果合约中没有updateOverdueStatus方法，需要先部署新合约
            // TransactionReceipt txReceipt = receivableContract.updateOverdueStatus(
            //     receivableId,
            //     overdueLevelValue,
            //     overdueDaysValue,
            //     updateTimestamp
            // );

            // 临时处理：如果合约方法不存在，记录日志并返回模拟txHash
            log.warn("updateOverdueStatus方法需要在Receivable合约中实现，当前使用模拟交易哈希");
            String txHash = "0x" + java.util.UUID.randomUUID().toString().replace("-", "");

            log.info("应收账款逾期状态更新成功上链: receivableId={}, txHash={}",
                     receivableId, txHash);

            return txHash;

        } catch (BlockchainIntegrationException e) {
            log.error("Failed to update overdue status on blockchain: receivableId={}",
                     receivableId, e);
            throw e;
        } catch (Exception e) {
            log.error("Failed to update overdue status on blockchain: receivableId={}",
                     receivableId, e);
            throw new BlockchainIntegrationException.ContractCallException(
                    receivableContractAddress, "updateOverdueStatus", e.getMessage(), e);
        }
    }

    /**
     * 转换催收类型为BigInteger
     */
    private BigInteger convertRemindTypeToBigInteger(String remindType) {
        if (remindType == null) {
            return BigInteger.ZERO;
        }
        switch (remindType.toUpperCase()) {
            case "EMAIL":
                return BigInteger.ZERO;
            case "SMS":
                return BigInteger.ONE;
            case "PHONE":
                return BigInteger.valueOf(2);
            case "LETTER":
                return BigInteger.valueOf(3);
            case "LEGAL":
                return BigInteger.valueOf(4);
            default:
                return BigInteger.ZERO;
        }
    }

    /**
     * 转换罚息类型为BigInteger
     */
    private BigInteger convertPenaltyTypeToBigInteger(String penaltyType) {
        if (penaltyType == null) {
            return BigInteger.ZERO;
        }
        return "AUTO".equalsIgnoreCase(penaltyType) ? BigInteger.ZERO : BigInteger.ONE;
    }

    /**
     * 转换坏账类型为BigInteger
     */
    private BigInteger convertBadDebtTypeToBigInteger(String badDebtType) {
        if (badDebtType == null) {
            return BigInteger.ZERO;
        }
        switch (badDebtType.toUpperCase()) {
            case "OVERDUE_180":
                return BigInteger.ZERO;
            case "BANKRUPTCY":
                return BigInteger.ONE;
            case "DISPUTE":
                return BigInteger.valueOf(2);
            case "OTHER":
                return BigInteger.valueOf(3);
            default:
                return BigInteger.ZERO;
        }
    }

    /**
     * 转换逾期等级为BigInteger
     */
    private BigInteger convertOverdueLevelToBigInteger(String overdueLevel) {
        if (overdueLevel == null) {
            return BigInteger.ZERO;
        }
        switch (overdueLevel.toUpperCase()) {
            case "MILD":
                return BigInteger.ZERO;
            case "MODERATE":
                return BigInteger.ONE;
            case "SEVERE":
                return BigInteger.valueOf(2);
            case "BAD_DEBT":
                return BigInteger.valueOf(3);
            default:
                return BigInteger.ZERO;
        }
    }

    /**
     * 计算SHA-256哈希值
     */
    private byte[] calculateSHA256(String data) {
        try {
            java.security.MessageDigest digest = java.security.MessageDigest.getInstance("SHA-256");
            return digest.digest(data.getBytes(java.nio.charset.StandardCharsets.UTF_8));
        } catch (java.security.NoSuchAlgorithmException e) {
            log.error("SHA-256 algorithm not found", e);
            return new byte[32];
        }
    }
}
